Angular - Framework Web, Mobile e Desktop.

AngularJS x Angular (Diferentes)

Por que Angular?
Rápido, moderno, simplificado, produtivo.

Angular é baseado em componentes. A aplicação é a coleção de componentes (Consome API Rest através de services).
Um componente tem template que está junto com a classe que possui propriedades e métodos com seus metadados.

TypeScript - Conjunto SuperSet de JavaScript. Fortemente tipado. Ferramental rico na IDE. Precisa transpilar (na hora de compilar, gera um JavaScript). Desenvolvido pela Microsoft, criada pelo pai do C# e .NET, open source, baseado em orientação a objetos. 

Requisitos: (REQUERIDO) HTML, CSS, JS. (DESEJÁVEL) Orientação a objetos, C# ou Java. (NÃO REQUERIDO) Angular 1.X, TypeScript.

Setup do ambiente: NodeJS, NPM (Já vem com Node). Instalação do Angular CLI - npm install -g @angular/cli. 

Os arquivos spec são para teste, logo podemos deletá-los.

Components: 
Primeira linha é importada a diretiva que é um componente do framework próprio do angular.
O que vai dizer que é um componente é o @component. O selector é o nome como você irá invocar esse componente. Logo após temos o caminho do template(html) e o caminho do estilo(css).
A exportação da classe usando typscript e o título que é uma variável.
Para criar um componente: ng generate component pasta/NomeComponente
ou ng g c NomeComponente (abreviados)

Decorators:
Um decorator define o comportamento de uma classe do Angular.
Para criar - ng g module NomeModulo

Service:
Na declaração é injectable (injetável). Providedin: 'root' é provisionado na raiz, serviço da raiz. Declaração da classe e construtor.
Esse serviço precisa ser registrado no módulo, pega o nome e coloca dentro de providers no module.ts, fazer também a importação da pasta.
Para gerar: ng g service Servico

------------------- Criando a aplicação ---------------------

ng new --minimal -g MeuProjeto (usando minimal para criar o projeto mais básico, sem os documentos de teste. E -g pra não criar o repositório do Git).

------------------- Framework de Front-End ---------------------

Bootstrap x Angular Material.
Iremos utilizar o bootstrap para a aplicação.
Bootstrap usa JavaScript com JQuery, não podemos misturar jQuery com Angular.
NGX-Bootstrap encapsula essa parte jQuery para Angular. (Mas não é necessário, só se for usar algum recurso que seja dependente de JS)

------------------- Dando uma cara a aplicação ---------------------

O index.html é só a estrutura.
Vamos remover o template do arquivo por templateUrl;
Adicionado conteúdo HTML estilizado com Bootstrap.

------------------- Definindo os componentes ---------------------

Criando o componente com ng g c navegacao/menu.
Criando o componente com ng g c navegacao/home.
Criando o componente com ng g c navegacao/footer.
Removendo a implementação OnInit pois não vamos utilizar programação nesses componentes.
Colocando os devidos conteúdos em cada um dos html dos componentes.
Criamos a pasta de navegação com os componentes (inicial, rodapé e menu). O app.component.html possui apenas o que ele precisa exibir.

------------------- Roteamento no Angular ---------------------

Criando a pasta institucional e os componentes sobre e contato
ng g c institucional/sobre
ng g c institucional/contato
Criando arquivo de rotas: app.routes.ts
Adicionando as rotas no arquivo, e depois configurando no módulo principal (app.module.ts). Importar o RouterModule e o APP_BASE_HREF pra informar que o link base é o /.
No app.component.html removemos o <app-home> e vamos utilizar a diretiva de navegação <router-outlet>.
No menu.component.html removi os href para usar a diretiva [routerLink].

------------------- Tipos de DataBind ---------------------

Forma de exibir dados.
Interpolation: Forma mais fácil de exibir um dado. É representado no template por dois pares de chaves, exemplo: <label>Nome: {{meuDado}} </label>.
Property Binding: Define valor de uma propriedade do elemento HTML, exemplo: <img [src]="minhaUrl> (é a mesma coisa de fazer: <img src="{{minhaUrl}}">). É um conceito de One-way binding por que o valor da variável vem do componente até a property mas não faz o caminho contrário.
Event Binding: Realiza a chamada de um método com base no evento do elemento HTML, exemplo: <button (click)='clickContador()'>Clique-me</button>. É muito utilizado para a submissão de formulários ou qualquer necessidade de processamento no componente com base em eventos conhecidos dos elementos HTML.
Two-way Binding: Exibe e atualiza um dado nas duas direções (template, componente), exemplo: 
<input class="form-control" type="text" [(ngModel)]="evento.nome" />
<label>Nome do evento: {{evento.nome}} </label>
É a união de property binding com event binding.

------------------- DataBind na prática ---------------------

Criei um novo componente: ng g c demos/DataBinding
Executei exemplos de interpolation, passando o valor entre {}. Exemplo de property binding passando o parâmetro entre [] pro Angular tomar de conta. Exemplo de event binding colocando o evento entre () para executar a função. Exemplo de two-way binding, primeiro comentando um código que simula esse resultado, e logo após usando de forma correta.
O ngModel é o modelo. Toda vez que esse modelo for alterado então o nome vai receber o evento e depende de um módulo que não tinhamos importado. Para ele funcionar importamos no modulo o FormsModule no arquivo module.ts.


------------------- Fake back-end ---------------------

Primeiro instalei o pacote json.server utilizando o comando npm i json-server(roda em qualquer lugar).
Criado arquivo produtos.json, com uma lista de produtos. 
Rodando o comando json-server --watch nomeJson na pasta do projeto.


------------------- Criando o serviço ---------------------

Para ser um serviço a classe precisa ter o @Injectable do angular/core. Logo após devemos registrar no módulo esse serviço.
Primeiro precisamos de um endpoint.
HttpClient, importando e passado como parâmetro pro construtor do serviço. 
Importando o Observable, que é o callback que vai avisar quando receber algo.

------------------- Consumindo o serviço através do componente ---------------------

Criado o novo componente: ng g c produtos/ListaProduto
Nas routes.ts adicionar o caminho pra esse componente. E o caminho para o produto-detalhe passando o id como parâmetro.
Dentro desse componente criamos uma lista do tipo produto para receber os produtos. E no método OnInit chamamos o método obterProdutos usando o subscribe para escrever na lista. 
No component.html criamos a diretiva ngFor* para que seja criado um card para cada produto da lista de produtos. E nos respectivos campos, usamos interpolation {{}} para coletar os valores. E dentro do link criamos um [routerModule] para que seja possível visualizar os detalhes daquele determinado produto.
No module.ts importamos o httpClientModule. 

------------------- Utilizando pipe ---------------------

Pipe é um decorator, utilizado para fazer alterações nas representações. Como por exemplo o pipe currency, que transforma o valor em monetário. Ou o TitleCasePipe, que faz com que a primeira letra de cada palavra fique maiúscula. (Não funcionou)
Você pode criar seu próprio pipe.


------------------- Diretivas de decisão ---------------------

As mais utilizadas são ngIf, ngFor, ngSwitch ou SwitchCase.


------------------- Atualização de versão ---------------------

Excluir a página node_modules.
Instalar o npm-check-updates.
npm i npm-check-updates
Rodar o comando ncu
ncu -u para upgrade, sobscreve o arquivo.

------------------- Realizando debug ---------------------

Feito direto pelo inspecionar no navegador. (Apenas quando estiver no desenvolvimento)
No VSCode, extensões como Debugger for Chrome. 

------------------- Entregando a aplicação ---------------------

Realizar compilação em produção.
ng b --prod
A pasta dist criada sobe para o servidor.

***** Desenvolvimento avançado com Angular *****

------------------- Promises vs Observables ---------------------

Promise é uma promeça, que informa que irá retornar alguma coisa. Callback simples, que ao chamar o THEN estamos chamando o resultado (seja o erro ou o sucesso). 
Observable é um objeto mais completo, com pegada reativa (É uma promise mais completa). 
Criado um novo projeto ng new RXJS --minimal=true.
Criado método promise para exemplo, implementando exemplo simples no método onInit.
*Diferenças*
Promises: Nativas do ES6, eager, processa um único evento, não aceita cancelamento, não faz retry.
Observables: Objeto reativo RXJS, lazy, processa N eventos, aceita cancelamento e faz retry.

------------------- Angular Style Guide ---------------------

Guia para consulta. Boas práticas como uma coisa por arquivo (um componente, um serviço, uma classe), considerar usar até 400 linha de código. Fazer funções pequenas, considerar limitar funções em até 75 linhas.

------------------- Minha primeira Observable ---------------------

Criado método que retorna uma Observable do tipo string, usando o método next do subscriber. Diferença em relação a promise: Podemos enviar uma ou mais informações para o subscriber. Ao precisar receber mais de uma resposta ao longo do tempo, usamos Observable.

------------------- Entendendo o Observer ---------------------

Para o observador existir é preciso de um subscribe (operador/método). É uma estrutura de instruções pra trabalhar com a subscription. Ao criar o Observer respeitar a estrutura de retorno (next, error e complete).

------------------- Subscribe e Unsubscribe ---------------------

Criando classe usuário para o exemplo e duplicando método observable. Unsubscribe é usada para cancelar uma subscribe, diferente do complete.

------------------- Angular Reactive Forms ---------------------

Escalável, e mais robusto (focar nessa metodologia). Utilizando template básico do projeto para trabalhar com os formulários.

------------------- FormControls e FormGroups ---------------------

Primeiro criamos os componentes demonstrativos.
ng g c demos/reactiveForms/cadastro
Adicionamos o modulo ReactiveForms ao app.module.
Criamos o botão cadastro no componente html do menu, e inserimos o path do cadastro component no arquivo de rotas.
Criado formulário no componente cadastro, e estilizado no arquivo style.css geral.
No componente de cadastro foi criado um cadastroForm: FormGroup, e no método onInit foi instanciado um novo FormGroup passando todos os valores com o formControl. No componente html foi inserido a propriedade formControlName="nome" nos inputs do formulário.
(Para submeter um formulário pelo angular é preciso usar o (ngSubmit) no formulário.

------------------- FormBuilder ---------------------

No construtor do componente precisamos injetá-lo. Para utiliza-lo usamos os métodos, no exemplo usado o group. Recomendando a utilização.

------------------- Transformando formulário em objetos tipados ---------------------

Criado uma nova pasta, models. Criando a classe usuário.
Criando a implementação da classe usuário no component.ts.
this.usuario = Object.assign({}, this.usuario, this.cadastroForm.value);

------------------- Validação básica de formulários ---------------------

Usando Validators.
Criamos um span abaixo do input do nome para exibir uma mensagem de alerta e usamos a diretiva ngIf pra condicionar quando esse span será exibido. Usando a diretiva ngClass pra adicionar uma classe css ao input. (Forma manual)
Quando tiver mais de um erro específico, tratar o ? para ignorar quando for nulo.

------------------- Validação customizada ---------------------

Vamos utilizar o pacote ng-brazil (validações de cpf, cnpj e afins). Instalando:
npm i ng-brazil
npm install --save ng-brazil angular2-text-mask
Logo após as instalações, importar no arquivo de módulos.
No componente de cadastro usamos o NgBrazilValidators.cpf. Importamos o utilsBr que é uma biblioteca para usarmos as máscaras.
E pacote ng2-validation. Instalando:
npm i ng2-validation
Logo após a instalação precisamos importar no arquivo de módulos.
Mudanças no componente para novas validações.

------------------- Formulários dinâmicos ---------------------

Se tiver muitos formulários recomendado a usar dessa forma. (Apenas exemplo, tem o template na pasta)


------------------- Angular Modules ---------------------

Vantagens de usar muitos módulos e não apenas o app module ou root como principal e único módulo da aplicação.

------------------- Modulo básico compartilhado ---------------------

Três tipos: Módulo principal, módulo que agrupa uma série de responsabilidades (compartilhado) e módulo mais exclusivo (só existe para uma responsabilidade, com navegação própria).
Criando o módulo de navegação, e nesse módulo diferente do principal temos que ter os exports: []. Módulo mais básico, sem navegação própria/roteamento próprio e pode ser utilizado por outros módulos.
Todo módulo precisa ter importação do CommonModule.

------------------- Modulos de roteamento ---------------------

Na aplicação temos um classe para roteamento, mas vamos reestruturar.
Continuamos usando a constante com as rotas, porém o que antes era apenas uma classe passou a ser um módulo de roteamento, mudando assim tabém as configurações no arquivo module principal.


------------------- Lazy Loading de módulos ---------------------

Vamos criar um novo módulo para produtos, que será independente com seus próprios roteamentos e responsabilidades. 
Criando o novo componente:
ng g c demos/arquitetura-componentes/produto-dashboard
Criamos os arquivos module e route para esse componente.
No arquivo module importamos o NgModule, CommonModule e RouterModule.
No arquivo routes importamos também o NgModule, dessa vez o routes e routermodule e o componente. Fizemos a constante com as rotas, e fizemos os imports e exports necessários.
No arquivo de rotas principal configuramos o lazy loading chamando um módulo. 
Erro amigo: Ao criar nosso componente ele foi automaticamente importado no módulo principal, e ao criar o novo módulo importamos novamente. Não pode ter o componente importado em dois módulos, logo, basta remover o import e declaration do módulo principal.

------------------- Input decorator ---------------------

Comunicação entre componentes.
@Input a direção é sempre do componente pai para o componente filho.
Para passar do filho pro pai usa o @Output.
Usando o template pronto, criado e exibido a lista do produtos. 
Usamos o decorator @input e criamos uma variável do tipo específico, onde o pai vai passar esse valor através de uma property binding.

------------------- Output decorator ---------------------

Comunicando de filho pra pai.
@Output criado para mudar o status do produto de ativo para não ativo.
No componente html filho fizemos um evento que chama um método que vai emitir um evento. No componente fizemos um método para emitir o evento, e esse evento é um output através do EventEmitter. 
No componente html pai, criamos um property binding pra entrada de dados do produto, e o event binding pra saída de dados chamando o método mudarStatus e passando o evento como propriedade, e no componente fizemos um método que recebe o produto e muda o status do produto.

------------------- Ng-content projection ---------------------

Usando ng-content no componente html filho para dizer que existe um conteúdo a ser inserido. E no componente html pai definidos esse conteúdo. Usando o select para definir a classe de qual mensagem será exibida em cada momento.

------------------- View-Children / Child decorator ---------------------

No componente html criamos um identificador #teste. No componente usamos o decorator ViewChild (singular), passando o id teste e o false pra trabalhar apenas com um elemento. Implementamos a interface AfterViewInit, e dentro desse método criamos uma variável para receber o elemento nativo de um evento.

------------------- Tratamento do 404 ---------------------

Criando o componente de notfound.
ng g c navegacao/notFound
No arquivo de rotas criamos um path '**' para pegar os caminhos em geral que não forem reconhecidos como rotas para tratar como 404. Porém precisamos lembrar de colocar esse path como último. (O erro 404 é para o roteamento do Angular).

------------------- Estilização da rota ativa ---------------------

No componente html do menu, usando a diretiva routerLinkActive="active" para passar o estilo do boostrap da classe active.
Usando o [routerLinkActiveOptions]="{ exact: true }" para verificar se a rota considerada é exatamente a mesma ou se é filha ou variante.

------------------- Links de navegação dinâmica ---------------------

No componente de menu criamos uma interface, e dentro do componente criamos um array de nav passando os valores da interface.
No componente html do menu, comentamos a maneira anterior (hard codded) e fizemos da nova maneira (dinâmica), usando um ngFor para pegar todos os itens e passando os parâmetros nas diretivas.

------------------- Rotas filhas em módulo externo ---------------------

Criando um novo componente
ng g c demos/arquitetura-componentes/editarProduto
Nas rotas criamos um novo path, e passamos como parâmetro 'editar:id'. 
No modulo principal vamos alterar o link base. Removemos o APP_BASE_HREF de providers. E no index.html dentro do head criamos o <base href="/">. (Uma forma, mais simples)
E podemos fazer um próprio módulo se rotear. No produto routes criamos um children e colocamos o path nessa rota filha. E para que funcione precisamos primeiramente criar um produto.app.component.ts (componente principal do modulo de produtos) e no template declaramos o routeroutlet. Importamos no produto module o componente ProdutoAppComponent. Nas rotas, adicionamos o dashboard também aos filhos, e o path vazio agora aponta para ProdutoAppComponent. (Roteamento autônomo, mais puro, porém mais complexo)


------------------- Obtendo parâmetros da rota ---------------------

Criado a classe para service, para simular o serviço que iria até o backend e registrando a classe nos providers do produto module.
No editar-produto componente usamos o método onInit para obter o id atraves da rota.
Criamos um html para exibir o produto selecionado.

------------------- Navegação imperativa com RouterAPI ---------------------

No componente do editar produto criamos o método salvar, e no construtor chamamos outra classe: router. Usamos o método navigate (invoca a rota sem perceber, já o navigateByUrl recarrega a página).

------------------- Route Tracing ---------------------

No arquivo de rotas principal, temos a coleção de rotas. No imports passamos um novo parâmetro: enableTracing: true (habilitando-o). 

------------------- Route Resolves e Snapshots ---------------------

No produto routes inserimos um parâmetro no caminho para ProdutoDashboard. E criando o redirecionamento para todos.
Dentro dos serviços criamos o produtos.resolve.ts e nos providers do módulo registramos esse serviço.
No dashboard dos produtos, removemos a lista de produtos do método onInit e agora passamos um parâmetro para o construtor do tipo ActivatedRoute e no onInit pegamos os produtos por essa rota ativa.


------------------- Obtendo dados da rota ---------------------

No produto routes, no caminho que recebe o parâmetro estado criamos um data que recebe uma string. Para exibir essa string, no componente do dashboard usamos um console.log recebendo o dado dessa rota ativa.

------------------- Route Guards ---------------------

Criamos um novo módulo para admins.
E o componente admin-dashboard.
ng g c admin/admin-dashboard
(Módulo semelhante ao módulo de produto, com rota própria configurada e feito as devidas alterações no menu para seu uso)
No app routes, no path para admin criamos um novo parâmetro: canLoad, que permite informar se devemos ou não carregar esse caminho, e dentro do canLoad coloamos o guarda da rota (serviço).
Na pasta raiz do app criamos uma pasta para serviços, e criamos o arquivo app.guard.ts. E registramos esse serviço no módulo.
No guard criamos um user, e usamos os métodos canLoad (para carregar) e canActivate (para acessar). CanLoad é pro módulo lazyload.

------------------- Route canDeactivate Guard ---------------------

Diferente do exemplo anterior, esse guarda impede que saia da rota. 
Alteramos o componente de cadastro para conseguir pegar o status se ele está sujo ou não.
Criamos um novo serviço para importar o canDeactivate.

------------------- Pipes no Angular ---------------------

Criamos um componente para filmes
ng g c demos/pipes/filmes
E uma classe de filme.ts
Usando os pipes no html de filme para exibir melhor os dados. Por exemplo: usando o | date para exibir a data de lançamento de um formato melhor de ler, usando o | currency para transformar o valor em monetário... 

------------------- Pipes customizados ---------------------

Criando um arquivo filesize.pipe, que será um pipe customizado para exibir o tamanho do arquivo em megabytes, gigabytes. E registramos junto dos componentes no módulo.


------------------- Pipe providers ---------------------

Aplicamos o pipe direto no component, e não no html.
Criamos um novo arquivo, image.pipe. 

------------------- Providers - UseClass ---------------------

(Aula importante, criando uma startup separada)
Criamos um módulo para o bar.
Também um serviço, e o componente.
ng g c demos/bar-di-zones/bar
Apenas um novo modo de usar o providers, passando direto o serviço ou usando o useClass pra passar uma classe.

------------------- NgModules - Injection Token ---------------------

No bar module teremos um método estático que fará a configuração forRoot.
Criamos o arquivo bar.config. 

------------------- Providers - UseFactory ---------------------

No bar service criamos uma fábrica que vai retornar BarServices.
No componente de bar criamos um novo provider, que irá usar o useFactory. Porém ele não trabalha sozinho, é preciso passar as dependencias.

------------------- NgZones ---------------------

Executando exemplo no bar componente.
Inserimos uns métodos para incremetar um processo (dentro do Angular Zone e fora). No construtor importamos o NgZone.
A diferença é que processar por dentro do Angular podemos acompanhar o progresso, enquanto processar por fora não dá pra acompanhar. (Por dentro mais elementos do Angular trabalham, processar fora te traz mais performance)

------------------- Gerenciamento de estado com RXJS ---------------------

(Todos os frameworks usam, inclusive o React que usa o Redux)
Utilizaremos o RXJS.

------------------- Estrutura do TO-DO ---------------------

Criado uma nova pasta para o to-do, criado também os componentes.
ng g c demos/todo-list < aqui temos o todo-component
ng g c demos/todo-list/components/tasks
ng g c demos/todo-list/components/tasks-finalizadas
ng g c demos/todo-list/components/tasks-iniciadas
ng g c demos/todo-list/components/todo-list
Criamos um módulo próprio e um serviço. Além de criar também uma interface task e um banco de dados usando json-server, chamado todo.db.json. (Para iniciar o banco usamos o comando json-server todo.db.json, dentro do diretório src/app/demos/todo-list)

------------------- Utilizando um serviço ---------------------

No serviço do todo, no construtor inserimos o http client (lembrando que pra funcionar precisa estar importado no módulo). E criamos um método para receber os dados da lista de tarefas. (Fizendo usando convenção, apenas propriedade).
*** REPLICADOS NOS 3 ***
No componente de (task, finalizado e iniciado) criamos um Observable importando também o serviço TasksService no construtor, e no método OnInit recebemos os valores usando a propriedade.
No html de (task, finalizado e iniciado) usamos property binding pra passar os valores dessa lista, e o pipe | async pra dizer que é um dado assincrono (que vai esperar o retorno).
*** REPLICADOS NOS 3 ***

------------------- Configurando a store ---------------------

Criado novo arquivo todo.store.ts.
Criamos uma interface com uma propriedade todolist que é uma coleção de tarefas. Criamos uma constante que vai representar o estado. E criamos uma classe, store. 
Usamos o BehaviorSubject que é uma classe que propaga o estado atual. 
No serviço, vamos injetar o store. No construtor criamos o private store e importamos, e no módulo precisamos registrar o Store no campo dos providers. Modificamos o método getTodoList para não ser chamado toda hora, utilizamos o pipe com o operador tap. 
Na tarefas iniciadas e finalizadas injetamos a store, e modificamos no OnInit para recuperar apenas as tarefas mapeadas. No componente das tarefas precisamos chamar o método subscribe para ativar o fluxo de dados, através da subscription (poderiamos colocar em outro lugar). E usamos o método onDestroy para fazer o unsubscription.